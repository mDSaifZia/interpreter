from custom_ast_nodes import *

class BytecodeGenerator:
    def __init__(self):
        self.bytecodes = []          # Active instruction list for current scope.
        self.func_bytecodes = {}     # Mapping: function name -> function definition instruction list.
        self.in_function = False     # Flag indicating if we are in a function.
        self.locals = None           # For function scope: maps variable name -> local index.

    # =============================== HElper functions ===============================
    def get_instruction_size(self, instruction):
        """
        Compute the size (in bytes) of a single instruction line based on the starting opcode.
        Standard size:
         - "INT <value>": 1 (opcode) + 8 (value) = 9 bytes.
         - "FLOAT <value>": 1 + 8.
         - "BOOL <value>": 1 + 1.
         - "STR <len> <string>": 1 (opcode) + 4 (length field) + (len) bytes.
         - "ID <num> <name>": 1 (opcode) + 2 (num field) + (num) bytes.
         - "IDFUNC <num> <name>": 1 + 2 + (num) bytes.
         - "LOCAL <index>": 1 + 2
         - Jump instructions ("OP_JMP" and "OP_JMPIF"): 1 (opcode) + 4 (offset) = 5 bytes.
         - "NUMARGS"/"NUMVARS": 1 + 4 = 5 bytes.
         - All other OP_* with no arguments: 1 byte.
        """
        tokens = instruction.split()
        if not tokens:
            return 0
        opcode = tokens[0]    # get the opcode for that instruction
        match opcode:
            case "INT" | "FLOAT":
                return 1 + 8
            case "BOOL":
                return 1 + 1
            case "STR":
                try:
                    strlen = int(tokens[1])
                except:
                    strlen = 0
                return 1 + 4 + strlen
            case "ID" | "IDFUNC":
                try:
                    num = int(tokens[1])
                except:
                    num = 0
                return 1 + 2 + num
            case "LOCAL":
                return 1 + 2
            case "OP_JMP" | "OP_JMPIF" | "NUMARGS" | "NUMVARS":
                return 1 + 4
            case _:
                if opcode.startswith("OP_"):
                    return 1
                else:
                    return 0

    def compute_size(self, instruction_list):
        # Return the total size (in bytes) of a list of instructions.
        total = 0
        for instruction in instruction_list:
            total += self.get_instruction_size(instruction)
        return total

    def get_instructions(self, node):
        # Temporarily generate list of instructions for a node and return them, without affecting the current self.bytecodes.
        actual_cur_bytecode = self.bytecodes    # Save the current bytecode list.
        self.bytecodes = []                     # Temporarily clear the bytecode list for traversing this node
        self.visit(node)
        result = self.bytecodes.copy()          # Copy the generated bytecode list for this node.
        self.bytecodes = actual_cur_bytecode    # Restore the original bytecode list.
        return result

    def generate_ifstmt_bytecode(self, if_node):
        """
        Compiles an if/else-if/else chain so that every branch (whether it has a condition or not)
        ends with an unconditional jump (OP_JMP) that directly skips to the end of the entire chain.
        Returns a list of instructions for the entire ifelse statement
        """
        # First, capture each branch as a tuple: (cond_code, then_code, has_condition)
        branches = []
        current = if_node
        while True:
            if hasattr(current, "condition") and current.condition is not None:
                cond_code = self.get_instructions(current.condition)
                then_code = self.get_instructions(current.then_branch)
                branches.append((cond_code, then_code, True))
            else:
                then_code = self.get_instructions(current.then_branch)
                branches.append(([], then_code, False))
            # Check if the else branch is itself an if-statement (i.e. an else-if)
            if current.else_branch is not None and type(current.else_branch).__name__ == "IfStmt":
                current = current.else_branch
            else:
                # Final else branch, if any.
                if current.else_branch is not None:
                    else_code = self.get_instructions(current.else_branch)
                    branches.append(([], else_code, False))
                break

        # For each branch, we want to add an unconditional jump at the end.
        # We'll compute for branch i: jump_offset = total size (in bytes) of all op-codes
        # for branches with index > i.
        branch_blocks = []
        for cond_code, then_code, has_condition in branches:
            if has_condition:
                # The condition branch: first, execute the condition.
                # If false, we jump past this branch’s then-code.
                # Here, the failure offset (for OP_JMPIF) is defined as:
                #    size(then_code) + 5  (5 bytes for the unconditional jump that follows then_code)
                branch_block = cond_code + [f"OP_JMPIF {self.compute_size(then_code) + 5}"]
            else:
                branch_block = []
            # Append the then-code and then an unconditional jump, offset calculated later
            branch_block += then_code + [f"OP_JMP {{placeholder_offset}}"]
            branch_blocks.append(branch_block)

        # for each branch, compute the total byte size of all branch_blocks that follow.
        num = len(branch_blocks)
        offsets = []
        for i in range(num):
            offset_to_end = 0
            for j in range(i+1, num):
                offset_to_end += self.compute_size(branch_blocks[j])
            offsets.append(offset_to_end)

        # Replace the placeholder in each branch with its computed offset.
        final_blocks = []
        for i, block in enumerate(branch_blocks):
            new_block = []
            for op in block:
                if op.startswith("OP_JMP {placeholder_offset}"):
                    new_block.append(f"OP_JMP {offsets[i]}")
                else:
                    new_block.append(op)
            final_blocks.append(new_block)

        # Concatenate all branch blocks into a single list.
        listof_entire_ifelse_statment = []
        for block in final_blocks:
            listof_entire_ifelse_statment.extend(block)
        return listof_entire_ifelse_statment
    
    def add_local(self, var_name):
        if self.locals is None:
            self.locals = {}
        idx = len(self.locals)
        self.locals[var_name] = idx
        return idx

    # =============================== Bytecode Generation ===============================
    def generate(self, ast):
        """
        Traverse the AST and generate two lists:
          - main_code: Global op-codes (terminated with OP_HALT)
          - func_defs: Function definition instructions.
        """
        self.in_function = False
        self.bytecodes = []
        self.visit(ast)
        main_code = self.bytecodes.copy()
        main_code.append("OP_HALT")
        func_defs = []
        for func_name, func_code in self.func_bytecodes.items():
            func_defs.extend(func_code)
        return main_code, func_defs

    def write_bytecode(self, ast, output_filepath):
        HEADER_SIZE = 64   # 64 bytes for header
        mainexec_start = HEADER_SIZE    # let main execution bytecode start right after the header
        classdef_bytecode_start = 0        # no class def yet so zero
        classdef_bytecode_end = 0

        # Get main execution, func def bytecodes and convert into bytes
        mainexec_bytecode, funcdef_bytecode = self.generate(ast)
        mainexec_bytecode_str = "\n".join(mainexec_bytecode) + "\n"
        funcdef_bytecode_str = "\n".join(funcdef_bytecode) + "\n"
        mainexec_inbytes = mainexec_bytecode_str.encode("utf-8")
        funcdef_inbytes = funcdef_bytecode_str.encode("utf-8")

        # Create bytecode file header (64 bytes)
        header = bytearray(HEADER_SIZE)
        header[::] = bytes(HEADER_SIZE)  # Initialize header with zero bytes

        # Write everything to file
        with open(output_filepath, 'wb') as f:
            f.write(header)
            f.write("\n".encode("utf-8"))
            f.write(mainexec_inbytes)
            f.write(funcdef_inbytes)
        # print(f"Bytecodes written to: {output_filepath}")

    def write_textfile(self, ast, output_filepath):
        # For debugging: write the bytecode to a text file also
        mainexec_bytecode, funcdef_bytecode = self.generate(ast)
        mainexec_bytecode_str = "\n".join(mainexec_bytecode) + "\n"
        funcdef_bytecode_str = "\n".join(funcdef_bytecode) + "\n"
        with open(output_filepath, 'w') as f:
            f.write(mainexec_bytecode_str)
            f.write("\n")
            f.write(funcdef_bytecode_str)
        # print(f"Bytecodes written to: {output_filepath}")

    # =============================== AST traversal ===============================
    def visit(self, node):
        method_name = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception(f"No visit_{node.__class__.__name__} method implemented")

    def visit_Program(self, node):
        for stmt in node.statements:
            # For global scope
            if (stmt.__class__.__name__ == "Assignment"): # If the assignment is a top-level assignment, we need to set it as such to prevent additional OP_GET
                stmt.top_level_assignment = True
            self.visit(stmt)

    def visit_VarDecl(self, node):
        self.visit(node.expr)
        if self.in_function:    # In function scope, add as local variable. May need to change.
            idx = self.add_local(node.identifier.name)
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_SET_LOCAL")
        else:                   # In global scope, add as global variable.
            self.bytecodes.append(f"ID {len(node.identifier.name)} {node.identifier.name}")
            self.bytecodes.append("OP_SET_GLOBAL")

    def visit_Assignment(self, node):
        self.visit(node.right)
        if self.in_function and self.locals and node.left.name in self.locals:  # Should check if variable is local or global
            idx = self.locals[node.left.name]
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_SET_LOCAL")
            # Push the value back for assignment chaining, unless it is top-level assignment which will be handled in visit_Program.
            if node.top_level_assignment == False:
                self.bytecodes.append(f"LOCAL {idx}")
                self.bytecodes.append("OP_GET_LOCAL")
        else:
            self.bytecodes.append(f"ID {len(node.left.name)} {node.left.name}")
            self.bytecodes.append("OP_SET_GLOBAL")   
            # Push the value back for assignment chaining.
            if node.top_level_assignment == False:
                self.bytecodes.append(f"ID {len(node.left.name)} {node.left.name}")
                self.bytecodes.append("OP_GET_GLOBAL")


    def visit_Literal(self, node):
        match node.type:
            case "int":
                self.bytecodes.append(f"INT {node.value}")
            case "float":
                self.bytecodes.append(f"FLOAT {node.value}")
            case "str":
                self.bytecodes.append(f"STR {len(node.value)} {node.value}")
            case "bool":
                self.bytecodes.append(f"BOOL {"1" if node.value else "0"}")
            case "null":
                self.bytecodes.append("__NULL__")
            case _:
                raise Exception(f"Unknown literal type {node.type}")

    def visit_Identifier(self, node):
        if self.in_function and self.locals and node.name in self.locals:       # Check scope
            idx = self.locals[node.name]
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_GET_LOCAL")
        else:
            self.bytecodes.append(f"ID {len(node.name)} {node.name}")
            self.bytecodes.append("OP_GET_GLOBAL")

    def visit_BinaryOp(self, node):
        self.visit(node.left)
        self.visit(node.right)
        op_map = {
            '+': 'OP_ADD',
            '-': 'OP_SUB',
            '*': 'OP_MUL',
            '/': 'OP_DIV',
            '%': 'OP_MOD',
            '==': 'OP_EQ',
            '!=': 'OP_NEQ',
            '>': 'OP_GT',
            '<': 'OP_LT',
            '>=': 'OP_GEQ',
            '<=': 'OP_LEQ',
            '&&': 'OP_LOGICAL_AND',
            '||': 'OP_LOGICAL_OR',
            '<<': 'OP_BLSHIFT',
            '>>': 'OP_BRSHIFT',
            '&': 'OP_BAND',
            '|': 'OP_BOR',
            '^': 'OP_BXOR',
        }
        op_instr = op_map.get(node.op)
        if op_instr is None:
            raise Exception(f"Unknown binary operator {node.op}")
        self.bytecodes.append(op_instr)

    def visit_UnaryOp(self, node):
        if node.op == '-':
            self.bytecodes.append("INT 0")
            self.visit(node.operand)
            self.bytecodes.append("OP_SUB")
        elif node.op == '!':
            self.visit(node.operand)
            self.bytecodes.append("BOOL 0")
            self.bytecodes.append("OP_EQ")
        else:
            raise Exception(f"Unknown unary operator {node.op}")

    def visit_ExpressionStmt(self, node):
        self.visit(node.expr)
        if (node.expr.__class__.__name__ == "CallExpr"):
            # Parent node of CallExpr is ExpressionStmt if its return value is not used.
            # Hence, if the expression is a function call, we need to add an OP_POP to discard the result at the end to prevent stack overflow.
            self.bytecodes.append("OP_POP")

    def visit_Block(self, node):
        for stmt in node.statements:
            # For local scope
            if (stmt.__class__.__name__ == "Assignment"): # If the assignment is a top-level assignment, we need to set it as such to prevent additional OP_GET
                stmt.top_level_assignment = True
            self.visit(stmt)

    def visit_IfStmt(self, node):
        # Use generate_ifstmt_bytecode() to generate the entire if–else chain op-codes.
        instructions = self.generate_ifstmt_bytecode(node)
        self.bytecodes.extend(instructions)

    def visit_PrintStmt(self, node):
        self.visit(node.expr)
        self.bytecodes.append("OP_PRINT")

    def visit_CallExpr(self, node):
        for arg in node.arguments:
            self.visit(arg)
        self.bytecodes.append(f"IDFUNC {len(node.callee.name)} {node.callee.name}")
        self.bytecodes.append("OP_CALL")

    def visit_FunctionDecl(self, node):
        original_bytecodes = self.bytecodes
        self.in_function = True
        self.locals = {}
        # Generate local variable dict from function parameters.
        for i, param in enumerate(node.params):
            self.locals[param.name] = i
        self.bytecodes = []
        # Generate the function definition body bytecodes and place in self.bytecodes.
        self.visit(node.body)
        if not self.bytecodes or self.bytecodes[-1] != "OP_RETURN": 
            # Ensure the function ALWAYS ends with a return statement
            self.bytecodes.append("__NULL__")
            self.bytecodes.append("OP_RETURN")
        
       # format full function def bytecodes and add to func_bytecodes
        func_body = self.bytecodes.copy()
        num_args = len(node.params)
        num_locals = len(self.locals)
        funcheader = []
        funcheader.append("OP_FUNCDEF")
        funcheader.append(f"NUMARGS {num_args}")
        funcheader.append(f"NUMVARS {num_locals}")
        funcheader.append(f"IDFUNC {len(node.name.name)} {node.name.name}")
        funcheader.extend(func_body)
        funcheader.append("OP_ENDFUNC")
        self.func_bytecodes[node.name.name] = funcheader
        # reset for next function
        self.in_function = False
        self.locals = None
        self.bytecodes = original_bytecodes

    def visit_ReturnStmt(self, node):
        self.visit(node.expr)
        self.bytecodes.append("OP_RETURN")

    def visit_WhileStmt(self, node):
        loop_start_pos = len(self.bytecodes)    # Starting position of the loop.
        cond_bytecode = self.get_instructions(node.condition)   # Get bytecode instructions for the condition.
        self.bytecodes.extend(cond_bytecode)
        jmpif_index = len(self.bytecodes)
        self.bytecodes.append("OP_JMPIF {placeholder_offset}")            # For jumping out of the loop if condition is false

        body_bytecode = self.get_instructions(node.body)    # Get bytecode instructions for the body.
        self.bytecodes.extend(body_bytecode)

        loopback_offset = self.compute_size(self.bytecodes[loop_start_pos:])    # Get offset to jump back to the start of the loop
        loopback_offset += 5  # Add 5 bytes for the OP_JMP instruction itself when going backwards
        self.bytecodes.append(f"OP_JMP {-loopback_offset}")                     # Unconditionally jumps to the start of the loop

        exitloop_offset = self.compute_size(self.bytecodes[jmpif_index+1:])
        self.bytecodes[jmpif_index] = f"OP_JMPIF {exitloop_offset}"  # Replace the placeholder with the actual offset 

    def visit_LoopStmt(self, node):
        # Get bytecode for starting value of loop control variable.
        startindex_bytecode = self.get_instructions(node.start_expr)
        self.bytecodes.extend(startindex_bytecode)
        if self.in_function:
            # Ensure the loop variable is in the local scope.
            if self.locals is None or node.var.name not in self.locals:
                idx = self.add_local(node.var.name)
            else:
                idx = self.locals[node.var.name]
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_SET_LOCAL")
        else:
            self.bytecodes.append(f"ID {len(node.var.name)} {node.var.name}")
            self.bytecodes.append("OP_SET_GLOBAL")
        
        loop_start_pos = len(self.bytecodes)    # Starting position of the loop.

        if self.in_function:
            if self.locals is None or node.var.name not in self.locals:
                idx = self.add_local(node.var.name)
            else:
                idx = self.locals[node.var.name]
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_GET_LOCAL")
        else:
            self.bytecodes.append(f"ID {len(node.var.name)} {node.var.name}")
            self.bytecodes.append("OP_GET_GLOBAL")
        # Get bytecode for ending value of loop control variable.
        endindex_bytecode = self.get_instructions(node.end_expr)
        self.bytecodes.extend(endindex_bytecode)
        
        # Compare the loop control variable with the end value to see if we should exit the loop
        self.bytecodes.append("OP_LEQ")
        jmpif_index = len(self.bytecodes)
        self.bytecodes.append("OP_JMPIF {placeholder_offset}")

        # Get loop body bytecode instructions.
        body_bytecode = self.get_instructions(node.body)
        self.bytecodes.extend(body_bytecode)

        # At the end of the loop body, we alsways increment the loop control variable by 1.
        if self.in_function:
            if self.locals is None or node.var.name not in self.locals:
                idx = self.add_local(node.var.name)
            else:
                idx = self.locals[node.var.name]
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_GET_LOCAL")
            self.bytecodes.append("INT 1")
            self.bytecodes.append("OP_ADD")
            self.bytecodes.append(f"LOCAL {idx}")
            self.bytecodes.append("OP_SET_LOCAL")
        else:
            self.bytecodes.append(f"ID {len(node.var.name)} {node.var.name}")
            self.bytecodes.append("OP_GET_GLOBAL")
            self.bytecodes.append("INT 1")
            self.bytecodes.append("OP_ADD")
            self.bytecodes.append(f"ID {len(node.var.name)} {node.var.name}")
            self.bytecodes.append("OP_SET_GLOBAL")
        
        # Jump back to the start of the loop
        loopback_offset = self.compute_size(self.bytecodes[loop_start_pos:])
        loopback_offset += 5  # Add 5 bytes for the OP_JMP instruction itself when going backwards
        self.bytecodes.append(f"OP_JMP {-loopback_offset}")  # Unconditionally jumps to the start of the loop

        # Get offset to exit the loop
        exitloop_offset = self.compute_size(self.bytecodes[jmpif_index+1:])
        self.bytecodes[jmpif_index] = f"OP_JMPIF {exitloop_offset}"




